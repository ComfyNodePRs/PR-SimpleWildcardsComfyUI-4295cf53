const WILDCARD_NAME = "SimpleWildcard";
const CONCAT_NAME = "SimpleConcat";
import { app } from "../../../scripts/app.js";
import { ComfyWidgets } from "../../../scripts/widgets.js";
app.registerExtension({
  name: WILDCARD_NAME,
  async nodeCreated(node, nodeData, app) {
    if (node?.comfyClass !== WILDCARD_NAME) return;
    const input_files_widget_index = node.widgets?.findIndex(
      (w) => w.name === "input_files",
    );
    const input_files_widget = node.widgets?.[input_files_widget_index];
    const input_text_widget = node.widgets?.find(
      (w) => w.name === "input_text",
    );
    let input_files = input_files_widget.value;
    let ac;
    Object.defineProperty(input_files_widget, "value", {
      get() {
        return input_files;
      },
      set(newValue) {
        input_files = newValue;
        ac?.abort();
        ac = new AbortController();
        fetch(`/simple-wildcards?path=${encodeURIComponent(newValue)}`, {
          signal: ac.signal,
        })
          .then(async (res) => {
            const data = await res.json();
            input_text_widget.value = "*";
            input_text_widget.options.values = data.items;
          })
          .catch((err) => {});
      },
      enumerable: true,
      configurable: true,
    });
    const output_text_widget = node.widgets?.find(
      (w) => w.name === "output_text",
    );
    output_text_widget.inputEl.placeholder = "output_text (autogenerated)";
    output_text_widget.inputEl.disabled = true;
    output_text_widget.inputEl.opacity = 0.6;
  },
  async beforeRegisterNodeDef(node, nodeData, app) {
    if (node?.comfyClass !== WILDCARD_NAME) return;
    const onExecuted = node.prototype.onExecuted;
    node.prototype.onExecuted = function (message) {
      onExecuted?.apply(this, arguments);
      const output_text_widget = this.widgets?.find(
        (w) => w.name === "output_text",
      );
      if (!output_text_widget) return;
      output_text_widget.value = message.output_text.join("");
      this.onResize?.(this.size); // onResize redraws the node
    };
  },
});

app.registerExtension({
  name: CONCAT_NAME,
  async nodeCreated(node, nodeData, app) {
    if (node?.comfyClass !== CONCAT_NAME) return;
    const num_widget = node.widgets?.find((w) => w.name === "num");
    let num = num_widget.value;
    Object.defineProperty(num_widget, "value", {
      get() {
        return num;
      },
      set(newValue) {
        num = newValue;
        for (let i = 0; i < 10; i++) {
          const name = `input_${i}`;
          if (i < num) {
            let widget = node.widgets?.find((w) => w.name === name);
            if (widget !== undefined) continue;
            widget = ComfyWidgets["STRING"](
              node,
              name,
              ["STRING", { default: "", multiline: true }],
              app,
            ).widget;
            node.onResize?.(node.size);
          } else {
            const widget_index = node.widgets?.findIndex(
              (w) => w.name === name,
            );
            if (widget_index >= 0) {
              const wid = node.widgets[widget_index];
              node.widgets.splice(widget_index, 1);
              wid?.onRemove();
              node.size = node.computeSize();
              node.setDirtyCanvas(true, true);
            }
          }
        }
      },
      enumerable: true,
      configurable: true,
    });
    const output_text_widget = node.widgets?.find(
      (w) => w.name === "output_text",
    );
    output_text_widget.inputEl.placeholder = "output_text (autogenerated)";
    output_text_widget.inputEl.disabled = true;
  },
  async beforeRegisterNodeDef(node, nodeData, app) {
    if (node?.comfyClass !== CONCAT_NAME) return;
    const onExecuted = node.prototype.onExecuted;
    node.prototype.onExecuted = function (message) {
      onExecuted?.apply(this, arguments);
      const output_text_widget = this.widgets?.find(
        (w) => w.name === "output_text",
      );
      if (!output_text_widget) return;
      output_text_widget.value = message.output_text.join("");
      this.onResize?.(this.size); // onResize redraws the node
    };
  },
});
